<!doctype html>
<html lang="th">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Balancing Act — PHX</title>
<link rel="icon" href="data:,">
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1620; --panel2:#121c29; --border:#1d2a3a;
    --text:#c7d2e0; --muted:#7f91a8; --primary:#9cff6a; --accent:#7ae0ff; --radius:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:radial-gradient(1100px 560px at 70% -10%,#0e1825 0%,transparent 60%),var(--bg);
    color:var(--text);
    font:14px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;
  }
  a{color:var(--accent); text-decoration:none}
  .wrap{max-width:1100px; margin:24px auto; padding:0 16px}

  /* header */
  .top{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:16px}
  .pill{display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border:1px solid var(--border); border-radius:999px;
        background:linear-gradient(180deg,var(--panel),var(--panel2)); color:#93a6be}
  h1{margin:0; font-size:18px}

  /* layout */
  .grid{display:grid; gap:16px; grid-template-columns: 1fr 260px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr} }

  .panel{
    border:1px solid var(--border);
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border-radius:var(--radius);
    padding:14px;
  }

  /* board */
  #board{position:relative; height:520px; background:linear-gradient(#0e2030 0 64%, #1b8030aa 64% 100%); border-radius:12px}
  .ground{position:absolute; left:0; right:0; bottom:0; height:36%; background:linear-gradient(#1b803044,#1b803000); border-bottom-left-radius:12px; border-bottom-right-radius:12px}

  /* pivot */
  .pivot { position:absolute; left:50%; bottom:160px; transform:translateX(-50%); width:28px; height:120px; background:#2b3a4c; border:1px solid #375068; border-radius:6px; }
  .pivot:after{ content:""; position:absolute; top:-10px; left:50%; transform:translateX(-50%); width:18px; height:18px; border-radius:50%; background:#cbd6e2; border:2px solid #7a8da6; }

  /* beam */
  .beam-wrap{ position:absolute; left:50%; bottom:220px; transform:translateX(-50%) rotate(0deg); transform-origin:50% 20px; transition:transform .15s ease-out; }
  .beam{ width:720px; height:20px; background:#d3aa72; border:2px solid #8a6b3f; border-radius:8px; position:relative; overflow:visible; }

  /* slot marks */
  .slot-mark{
    position:absolute; top:2px; width:2px; height:16px;
    background:#6e5736aa;
    pointer-events:none;
  }

  /* masses */
  .mass{
    width:44px; height:44px; border-radius:8px; color:#091018; display:flex; align-items:center; justify-content:center; font-weight:800;
    border:2px solid #1b2a3a; box-shadow:0 6px 16px #0008; position:absolute; cursor:grab; user-select:none;
    transition:left .08s ease-out; /* ขยับเข้าร่องให้รู้สึก "snap" */
  }
  .mass[data-mass="1"]{background:#c7ebff}
  .mass[data-mass="2"]{background:#9dd6ff}
  .mass[data-mass="5"]{background:#7ae0ff}
  .mass[data-mass="10"]{background:#9cff6a}
  .ghost{opacity:.45; filter:saturate(.5)}

  /* palette */
  .card h3{margin:0 0 8px 0; color:#9ab3cf; text-transform:uppercase; font-size:12px; letter-spacing:.6px}
  .palette{display:grid; grid-template-columns:repeat(2,1fr); gap:10px}
  .palette .mass{position:relative; static:initial; border:1px dashed #2b405b; box-shadow:none; width:56px; height:56px; cursor:grab}
  .palette .mass span{pointer-events:none}
  .note{color:#93a6be; font-size:12px; margin-top:8px}

  /* HUD */
  .hud{position:absolute; left:14px; top:14px; display:flex; gap:12px; font-size:12px; color:#a8bdd6}
  .hud .pill{padding:6px 10px}
</style>

<div class="wrap">
  <div class="top">
    <span class="pill">PHX • Mechanics</span>
    <h1>Balancing Act (Web)</h1>
    <a class="pill" href="../index.html">← Back to Catalog</a>
  </div>

  <div class="grid">
    <!-- Board -->
    <div class="panel" id="boardPanel">
      <div id="board">
        <div class="hud">
          <span class="pill">Torque L: <b id="tL">0</b></span>
          <span class="pill">Torque R: <b id="tR">0</b></span>
          <span class="pill">Angle: <b id="ang">0°</b></span>
        </div>

        <div class="beam-wrap" id="beamWrap">
          <div class="beam" id="beam"></div>
        </div>
        <div class="pivot"></div>
        <div class="ground"></div>
      </div>
    </div>

    <!-- Palette -->
    <aside class="panel">
      <h3>Mass Palette</h3>
      <div class="palette" id="palette">
        <div class="mass" data-mass="1"><span>1 kg</span></div>
        <div class="mass" data-mass="2"><span>2 kg</span></div>
        <div class="mass" data-mass="5"><span>5 kg</span></div>
        <div class="mass" data-mass="10"><span>10 kg</span></div>
      </div>
      <div class="note">ลากก้อนน้ำหนักจากพาเลทไปวางบนคาน — ตอนปล่อยจะ “ล็อก” เข้าช่องขีดบนคานอัตโนมัติ</div>
      <div class="note">ลากก้อนที่อยู่บนคานออกนอกคานเพื่อเอาออก</div>
    </aside>
  </div>
</div>

<script>
/* ======= Elements ======= */
const beamWrap = document.getElementById('beamWrap');
const beam     = document.getElementById('beam');
const palette  = document.getElementById('palette');

const tL = document.getElementById('tL');
const tR = document.getElementById('tR');
const ang = document.getElementById('ang');

/* ======= Slot configuration ======= */
/* จะได้ช่อง -SLOT_COUNT..0..+SLOT_COUNT (รวม 2*SLOT_COUNT+1 จุด) */
const SLOT_COUNT = 6;        // ปรับ 6–10 ตามต้องการ
const MASS_BOTTOM = 20;      // ยกก้อนเหนือคานเล็กน้อย
const MAX_ANGLE = 15;
const TORQUE_TO_ANGLE = 2.0;

let SLOT_PX = 0;             // ระยะห่างช่องจริง (คำนวณอัตโนมัติ)

/* ======= Utilities ======= */
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function wrapRect(){ return beamWrap.getBoundingClientRect(); }
function computeSlotPx(){
  const gutter = 16;
  const usable = beam.clientWidth - gutter*2;
  SLOT_PX = usable / (SLOT_COUNT*2);
}
function slotToX(slotIdx){
  return beam.clientWidth/2 + slotIdx * SLOT_PX;
}

/* วาดขีดสเกลบนคาน */
function drawSlots(){
  beam.querySelectorAll('.slot-mark').forEach(n=>n.remove());
  for(let i=-SLOT_COUNT;i<=SLOT_COUNT;i++){
    const m = document.createElement('div');
    m.className = 'slot-mark';
    m.style.left = (slotToX(i)-1) + 'px';
    beam.appendChild(m);
  }
}

/* ======= State ======= */
const onBeam = []; // { el, mass, slot }

/* ======= Physics ======= */
function recalc(){
  let L=0, R=0;
  for(const o of onBeam){
    if(o.slot<0) L += Math.abs(o.slot) * o.mass;
    else if(o.slot>0) R += Math.abs(o.slot) * o.mass;
  }
  tL.textContent = L.toFixed(2);
  tR.textContent = R.toFixed(2);
  const theta = clamp((R-L) * TORQUE_TO_ANGLE, -MAX_ANGLE, MAX_ANGLE);
  ang.textContent = theta.toFixed(1)+'°';
  beamWrap.style.transform = `translateX(-50%) rotate(${theta}deg)`;
}

/* ======= Drag & Drop ======= */
let dragging = null; // { ghostEl, mass, fromPalette, fromObj? }

function createMassEl(mass){
  const el = document.createElement('div');
  el.className = 'mass';
  el.dataset.mass = mass;
  el.innerHTML = `<span>${mass} kg</span>`;
  return el;
}
function followPointer(el, e){
  el.style.position='fixed';
  el.style.left = (e.clientX - el.offsetWidth/2)+'px';
  el.style.top  = (e.clientY - el.offsetHeight/2)+'px';
}

function startDragFromPalette(src){
  const mass = +src.dataset.mass;
  const ghost = createMassEl(mass); ghost.classList.add('ghost');
  document.body.appendChild(ghost);
  dragging = { ghostEl: ghost, mass, fromPalette: true };
}
function startDragFromBeam(obj){
  const ghost = createMassEl(obj.mass); ghost.classList.add('ghost');
  document.body.appendChild(ghost);
  // เอาของเดิมออกจากคานชั่วคราว
  const i = onBeam.indexOf(obj);
  if(i>=0) onBeam.splice(i,1);
  obj.el.remove();
  dragging = { ghostEl: ghost, mass: obj.mass, fromPalette:false, fromObj: obj };
  recalc();
}

function nearestSlotIndexByClientX(clientX){
  const r = wrapRect();
  const x = clientX - r.left;
  const cx = beam.clientWidth/2;
  const idx = Math.round((x - cx)/SLOT_PX);
  return clamp(idx, -SLOT_COUNT, SLOT_COUNT);
}
function isOccupied(slotIdx){ return onBeam.some(o=>o.slot===slotIdx); }
/* หา “ช่องว่างที่ใกล้ที่สุด” เผื่อช่องที่เล็งอยู่ถูกยึด */
function findNearestFreeSlot(preferred){
  if(!isOccupied(preferred)) return preferred;
  for(let d=1; d<=SLOT_COUNT; d++){
    const L = preferred - d, R = preferred + d;
    if(L>=-SLOT_COUNT && !isOccupied(L)) return L;
    if(R<=+SLOT_COUNT && !isOccupied(R)) return R;
  }
  return null; // เต็ม
}

/* handlers */
function onMouseMove(e){
  if(!dragging) return;
  followPointer(dragging.ghostEl, e);
}
function finishDrag(e){
  if(!dragging) return;

  const r = wrapRect();
  const insideBeam = (e.clientX>=r.left && e.clientX<=r.right &&
                      e.clientY>=r.top-80 && e.clientY<=r.bottom+40);
  if(insideBeam){
    let slot = nearestSlotIndexByClientX(e.clientX);
    slot = findNearestFreeSlot(slot);
    if(slot!==null){
      const placed = createMassEl(dragging.mass);
      placed.style.position='absolute';
      placed.style.left = (slotToX(slot) - placed.offsetWidth/2) + 'px';
      placed.style.bottom = MASS_BOTTOM + 'px';

      placed.onmousedown = () => {
        const obj = onBeam.find(o=>o.el===placed);
        if(obj){ startDragFromBeam(obj); bindDoc(); }
      };

      beamWrap.appendChild(placed);
      onBeam.push({ el: placed, mass: dragging.mass, slot });
      recalc();
    }
  }
  dragging.ghostEl.remove();
  dragging = null;
}
function bindDoc(){
  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', (ev)=>{
    document.removeEventListener('mousemove', onMouseMove);
    finishDrag(ev);
  }, {once:true});
}

/* palette events */
palette.querySelectorAll('.mass').forEach(m=>{
  m.addEventListener('mousedown', ()=>{
    startDragFromPalette(m);
    bindDoc();
  });
});

/* delegate: drag ของบนคาน */
beamWrap.addEventListener('mousedown', (e)=>{
  const el = e.target.closest('.mass');
  if(!el) return;
  const obj = onBeam.find(o=>o.el===el);
  if(!obj) return;
  startDragFromBeam(obj);
  bindDoc();
});

/* ======= Init / Resize ======= */
function firstPaint(){
  computeSlotPx();
  drawSlots();
  recalc();
}
window.addEventListener('resize', ()=>{
  computeSlotPx();
  // จัดก้อนที่มีอยู่ให้ตรงตำแหน่ง slot อีกครั้ง
  onBeam.forEach(o=>{
    o.el.style.left = (slotToX(o.slot) - o.el.offsetWidth/2) + 'px';
  });
  drawSlots();
  recalc();
});

firstPaint();
</script>
</html>
